import { NextResponse } from 'next/server';
import { getYouTubeClient } from '@/lib/youtube-auth';
import { searchYouTubeVideos } from '@/lib/youtube-search';
import { ShazamTrack } from '@/lib/csv-parser';

interface PlaylistRequest {
  tracks: ShazamTrack[];
  accessToken: string;
  playlistTitle: string;
  action: 'create' | 'overwrite' | 'update';
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { tracks, accessToken, playlistTitle = 'My Shazam Tracks' } = body;
    let { action = 'create' } = body;

    // Validate required fields
    if (!tracks || !accessToken) {
      return NextResponse.json(
        { error: 'Missing required fields: tracks and accessToken are required' },
        { status: 400 }
      );
    }

    if (!Array.isArray(tracks) || tracks.length === 0) {
      return NextResponse.json(
        { error: 'No tracks provided or tracks array is empty' },
        { status: 400 }
      );
    }

    const youtube = getYouTubeClient(accessToken);
    let playlistId: string | undefined = undefined;
    let existingTrackIds: Set<string> = new Set();

    // Handle different actions
    if (action === 'update' || action === 'overwrite') {
      // Find existing playlist
      const playlistsResponse = await youtube.playlists.list({
        part: ['snippet'],
        mine: true,
        maxResults: 50
      });

      const existingPlaylist = playlistsResponse.data.items?.find(
        playlist => playlist.snippet?.title?.toLowerCase() === playlistTitle.toLowerCase()
      );

      if (existingPlaylist) {
        playlistId = existingPlaylist.id!;

        if (action === 'update') {
          // Get existing tracks to avoid duplicates
          const playlistItemsResponse = await youtube.playlistItems.list({
            part: ['snippet'],
            playlistId: playlistId,
            maxResults: 50
          });

          existingTrackIds = new Set(
            playlistItemsResponse.data.items?.map(item => 
              item.snippet?.resourceId?.videoId
            ).filter(Boolean) as string[]
          );
        } else if (action === 'overwrite') {
          // Remove all existing items
          const playlistItemsResponse = await youtube.playlistItems.list({
            part: ['snippet'],
            playlistId: playlistId,
            maxResults: 50
          });

          const existingItems = playlistItemsResponse.data.items || [];
          for (const item of existingItems) {
            try {
              await youtube.playlistItems.delete({
                id: item.id!
              });
            } catch (error) {
              console.error(`Failed to remove playlist item ${item.id}:`, error);
            }
          }
        }
      } else {
        // If playlist doesn't exist, fall back to create
        action = 'create';
      }
    }

    // Create new playlist if needed
    if (action === 'create' || !playlistId) {
      const playlistResponse = await youtube.playlists.insert({
        part: ['snippet', 'status'],
        requestBody: {
          snippet: {
            title: playlistTitle,
            description: `Created from Shazam export with ${tracks.length} tracks - Generated by Shazam to YouTube Converter`
          },
          status: {
            privacyStatus: 'private'
          }
        }
      });

      playlistId = playlistResponse.data.id!;
      if (!playlistId) {
        throw new Error('Failed to create playlist');
      }
    }

    // Search for videos and add to playlist
    const searchResults = await searchYouTubeVideos(youtube, tracks);
    const successfulAdds = [];

    for (const result of searchResults) {
      if (result.videoId && !existingTrackIds.has(result.videoId)) {
        try {
          await youtube.playlistItems.insert({
            part: ['snippet'],
            requestBody: {
              snippet: {
                playlistId: playlistId,
                resourceId: {
                  kind: 'youtube#video',
                  videoId: result.videoId
                }
              }
            }
          });
          successfulAdds.push(result.track);
        } catch (error) {
          console.error(`Failed to add ${result.track.artist} - ${result.track.title}:`, error);
        }
      }
    }

    const result = {
      success: true,
      playlistId,
      totalTracks: tracks.length,
      addedTracks: successfulAdds.length,
      failedTracks: tracks.length - successfulAdds.length,
      action: action === 'create' ? 'created' : action === 'overwrite' ? 'replaced' : 'updated'
    };

    return NextResponse.json(result);

  } catch (error) {
    console.error('Playlist creation error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to create playlist',
        success: false,
        totalTracks: 0,
        addedTracks: 0,
        failedTracks: 0
      },
      { status: 500 }
    );
  }
}